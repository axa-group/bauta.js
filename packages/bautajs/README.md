<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

### Table of Contents

-   [bautajs][1]
-   [How to install][2]
-   [Usage][3]
-   [Features][4]
    -   [Store][5]
    -   [Config][6]
    -   [Request Validation][7]
    -   [datasources][8]
    -   [multipart/related requests][9]
    -   [multipart/form-data requests][10]
    -   [Request like features][11]
    -   [Debug][12]
    -   [LoopbackFilters][13]
    -   [next, previous and fork hooks][14]
    -   [API versioning][15]
    -   [Set an Operation schema (endpoint schema)][16]
-   [Public API][17]
    -   [services][18]
        -   [Examples][19]
    -   [requireAll][20]
        -   [Parameters][21]
        -   [Examples][22]
    -   [store][23]
        -   [Examples][24]
    -   [batuajs][25]
        -   [Parameters][26]
        -   [Examples][27]
    -   [deref][28]
        -   [Parameters][29]
    -   [Artifacts][30]
        -   [Operation][31]
            -   [Parameters][32]
            -   [addMiddleware][33]
                -   [Parameters][34]
                -   [Examples][35]
            -   [dataSource][36]
                -   [Properties][37]
            -   [definitions][38]
                -   [Properties][39]
            -   [exec][40]
                -   [Parameters][41]
                -   [Examples][42]
            -   [exposeOperation][43]
                -   [Examples][44]
            -   [fork][45]
                -   [Parameters][46]
                -   [Examples][47]
            -   [join][48]
            -   [next][49]
                -   [Parameters][50]
                -   [Examples][51]
            -   [parametersSchema][52]
            -   [previous][53]
                -   [Parameters][54]
                -   [Examples][55]
            -   [run][56]
                -   [Parameters][57]
            -   [runFork][58]
                -   [Parameters][59]
            -   [schema][60]
            -   [serviceName][61]
                -   [Properties][62]
            -   [setErrorHandler][63]
                -   [Parameters][64]
                -   [Examples][65]
            -   [setLoader][66]
                -   [Parameters][67]
                -   [Examples][68]
            -   [setSchema][69]
                -   [Parameters][70]
                -   [Examples][71]
            -   [validate][72]
                -   [Parameters][73]
                -   [Examples][74]
        -   [Fork][75]
            -   [Parameters][76]
            -   [initIterator][77]
                -   [Parameters][78]
            -   [nextValue][79]
        -   [Step][80]
            -   [Parameters][81]
            -   [handleValue][82]
                -   [Parameters][83]
            -   [run][84]
                -   [Parameters][85]
            -   [runWithCallback][86]
                -   [Parameters][87]
            -   [runWithReturn][88]
                -   [Parameters][89]
        -   [Service][90]
            -   [Parameters][91]
        -   [Version][92]
            -   [Parameters][93]
            -   [addMiddleware][94]
                -   [Parameters][95]
                -   [Examples][96]
            -   [addOperation][97]
                -   [Parameters][98]
                -   [Examples][99]

## bautajs

A library to build easy versionable and self organized middlewares.


## How to install

Make sure that you have access to [Artifactory][100]

```console
  npm install bautajs
```


## Usage

To use bautaJS with the default configuration we will need to create the following folder structure:

-   server
    -   services
        -   v1
            -   cats
                -   cats-datasource.json
                -   cats-loader.js
                -   cats-schema.json
    -   server.js
    -   api-definitions.json

// cats-datasource.json

```json
{
  "cats": {
    "operations": [
      {
        "name": "find",
        "url": "{{config.endpoint}}/getsome"
      }
    ]
  }
}
```

// cats-loader.js

```js
  const catsSchema = require('./cats-schema.json');

  module.exports = services => {
    services.cats.v1.find
      .setSchema(catsSchema)
      .setLoader(function catLoaders(){
        this.req.logger.info('Fetching some cats');

        return this.dataSource.request();
      })
  };
```

// cats-schema.json

```json
  {
    "/cats": {
      "get": {
        "tags": ["cats"],
        "summary": "Get the list of cats",
        "operationId": "get-cats",
        "produces": ["application/json"],
        "responses": {
          "200": {
            "description": "successful operation",
            "schema": {
              "type": "array",
              "items": {
                "type": "Object",
                "properties": {
                  "name": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    }
```

// api-definitions.json

```json
  [
    {
      "versionId": "v1",
      "openapi": "3.0",
      "apiVersion": "1.0",
      "swaggerVersion": "1.0",
      "info": {
        "description": "API for cool cats",
        "version": "1.0.0",
        "title": "MyAXA API"
      },
      "basePath": "/v1/api/"
    }
  ]
```

// server.js

```js
    const bautaJS = require('bautajs');
    const apiDefinitions = require('./api-definitions.json');
    
    const config = {
      endpoint:'http://coolcats.com'
    }

    bautaJS(config, apiDefinitions);

    await bautaJS.services.cats.v1.find.exec({});
```

This will produce a request to `coolcats.com` with the result:

```json
  [
    {
      "name": "cat1"
    }
  ]
```


## Features




### Store

`bautajs` provides a built-in 'Map' singleton. Add data and get data from everywhere.
The singleton life is related to the life of the Node.js process. 

```js
  const { store } = require('bautajs');

  store.set('data', { foo: boo });

  const data = store.get('data');
```


### Config

By default `bautajs` will add the configuration you send in the initialization moment into a global store. So you can access the config
inside all the loaders by doing:

```js
  const { store } = require('bautajs');

  store.get('config');
```


### Request Validation

`bautajs` comes with a default request validation using the [openAPI schema][101]. By default, it is set to false.
By adding `validateRequest: true` on the operation datasource, request validation will be enabled.

### Example

  This is a datasource example:

```json
{
  "testService":{
    "operations":[
      {
        "name":"test",
        "url":"http://myserver.com",
        "validateRequest": true
      }
    ]
  }
}
```

  Alternative you can also validate inside every loader by accesing to the context `this.validate(this.req)` sending a req body or query.

```js
  services.cats.v1.find.previous(function pFn() {
    const error = this.validate(this.req);
    if(error) {
      throw error;
    }
  })
```


### datasources

The datasources are the main feature of the library. The dataSources define how the services will behave and from where the data will come.

### Define a datasource

To define a datasource, create a file into `"services/"` folder with a name ending on `"-datasource.json|js"`. The datasources are loaded automatically by the `bautajs` in bootstrap time.
A datasource containing a `url` property on its definition, represents a HTTP request (using [Got][102]).           

`By default request are done using [keepAlive](https://nodejs.org/api/http.html#http_new_agent_options)`

Without `url`, a datasource just describe an simple service operation.

### Datasource structure

`bautajs` datasources must be compliant with [./lib/validators/datasource-schema.json][103].

### Example

This is a datasource example:

```json
{
  "testService":{
    "operations":[
      {
        "name":"test",
        "url":"http://myserver.com",
        "options":{
          "json": true,
          "headers": {
            "Accept":"application-json"
          }
        }
      }
    ]
  }
}
```

### Dynamic datasources

Datasources used in every request are compiled on demand. It allow to add dynamic information into them, specifying properties from `req`, `config` and `env` (environment variables) objects. 
See the template syntax format at [json-templates][104].
to retrieve dynamic data.

```json
{
  "testService":{
    "operations":[
      {
        "name":"test",
        "url":"{{config.url}}",
        "options":{
          "json": true,
          "headers": {
            "Accept-Language": "{{req.headers.accept-language:ES_es}}",
            "x-axa-user-agent": "{{req.headers.x-axa-user-agent:My default user agent}}"
          }
        }
      }
    ]
  }
}
```

`Once the dynamic data is resolved, the fields with`undefined`or`null\` values, are removed from the request as [got definitions][102].

### Accessing compiled datasources from loader

Is possible to access to compiled datasources from the operations loaders.

```js
  // Launching the operation datasource request.
  services.cats.v1.find.setLoader(function myLoader() {
    return this.dataSource.request();
  });
  // Launching the operation datasource request with custom option.
  // They will be merged with the definition options.
  services.cats.v1.findById.setLoader(function myLoader() {
    const customOptions = { json: false };
    return this.dataSource.request(customOptions);
  });
```

```js
  // Launching other operation datasource request
  services.cats.v1.find.setLoader(function myLoader() {
    return services.documents.v1.find.dataSource(this.req).request();
  });
```

By default, `bautajs`, uses [got][102] library to launch the operation datasources requests.
However, is possible to use your preferred request module using the datasources definitions.

```js
  const request = require('request');
  services.cats.v1.find.setLoader(function myLoader(cb){
    const { method, url, options } = services.dogs.v1.find.dataSource(this.req);

    return request({ method, url, ...options }, cb);
  });
```

### Accessing a datasource from previous and middleware hooks

Accessing from a `previous` hook (see [Previous][105]) the datasource is not compiled yet. 
Is possible to add/modify datasources template options (e.g. headers) on the previous hooks.

On the other hand, is possible to compile the operation datasource in a previous hook. 
Even that, it will be compiled again on the loader phase as well.

```js
    services.cats.v1.previous(function prev() {
      const compiled = this.dataSource({req:this.req});
      // do something with compiled
    })
```


### multipart/related requests

[got][102] do not come with `multipart/related` out of the box.
Thus, `bautajs` add it to be available at the operations datasources requests.
`bautajs` follows the way [request/request][106] implements `multipart/related` by using [multipart-request-builder][107].

```text
  Do not add the multipart configuration in the operation datasource definition if it has streams (fs.createReadStream).
  It must be passed in the loader definition
```

```json
// my-datasource.json
// multipart/related without streams
{
  "testService": {
    "operations":  [
      {
        "name": "operation1",
        "headers": {
          "content-type": "multipart/related"
        },
        "preambleCRLF": true,
        "postambleCRLF": true
      }
    ]
  }
} 
```

```js
// my-loader.js
// multipart/related with stream
services.tstService.v1.operation1.setLoader(function loader(){
  return this.dataSource.requests({
    multipart: [
      {
        'content-type': 'application/json',
        body: JSON.stringify({
          foo: 'bar',
          _attachments: {
            'message.txt': {
              follaws: true,
              length: 18,
              'content_type': 'text/plain'
            }
          }
        })
      },
      {
        body: 'I am an attachment'
      },
      {
        body: fs.createReadStream('image.png')
      }
    ],
    // alternatively pass an object containing additional options multipart: {
    chunked: false,
    data: [
      {
        'content-type': 'application/json',
        body: JSON.stringify({
          foo: 'bar',
          _attachments: {
            'message.txt': {
              follows: true,
              length: 18,
              'content_type': 'text/plain'
            }
          }
        })
      },
      {
        body: 'I am an attachment'
      }
    ]
  }})
})
```


### multipart/form-data requests

As for `multipart/related`, `bautajs` provides its own implementation for `multipart/form-data`.

```text
  Do not add the multipart configuration in the operation datasource definition if it has streams (fs.createReadStream).
  It must be passed in the loader definition
```

```json
// my-datasource.json
// multipart/related without streams
{
  "testService": {
    "operations":  [
      {
        "name": "operation1"
      }
    ]
} 
```

```js
// my-loader.js
// multipart/related with streams
services.testService.v1.operation1.setLoader(function loader(){
  const formData = {
    // Pass a simple key-value pair
    my_field: 'my_value',
    // Pass data via Buffers
    my_buffer: Buffer.from([1, 2, 3]),
    // Pass data via Streams
    my_file: fs.createReadStream(__dirname + '/unicycle.jpg'),
    // Pass multiple values /w an Array
    attachments: [
      fs.createReadStream(__dirname + '/attachment1.jpg'),
      fs.createReadStream(__dirname + '/attachment2.jpg')
    ],
    // Pass optional meta-data with an 'options' object with style: {value: DATA, options: OPTIONS}
    // Use case: for some types of streams, you'll need to provide "file"-related information manually.
    // See the `form-data` README for more information about options: https://github.com/form-data/form-data
    file: {
      value:  fs.createReadStream('/file'),
      options: {
        filename: 'someImage.jpg',
        contentType: 'image/jpeg'
      }
    }
  };
  return this.dataSource.request({ formData });
});
```


### Request like features

To help on the transition from `request` to `got`, there are some alias and helpfull fields that feels like still using request library:

-   Use 'json' as an object to POST json data (content-type: application/json):

```json
  {
    "json": {
      "someFiled":"someValue"
    }
  }
```

-   Use 'form' as an object to POST data as url encoded form (content-type:application/x-www-form-urlencoded):

```json
  {
    "form": {
      "someFiled":"someValue"
    }
  }
```

-   Custom `Agent` allowing the following features:
    -   http_proxy and https_proxy environment variables
    -   Request using custom certificates throught 'cert' and 'key' native NODEJS fields
    -   StricSSL enable throught 'rejectUnauthorized' field


### Debug

One of the main purpose of `bautajs` is provide a nice debugging experience. 
The request options, the response body and the times a request takes are logged.
To activate the logs just set debug:

```cmd
LOG_LEVEL=debug DEBUG=bautajs*
```

Furthemore, if you want to censor some words we strongly recomend use [pino redaction][108]


### LoopbackFilters

The `bautajs` allows to use [loopback filters][109] over arrays.
Add the applyLoopbackFilters option to datasource operations:

### Example

```json
{
  "testService":{
    "operations":[
      {
        "name":"test",
        "url":"http://myserver.com",
        "applyLoopbackFilters": true,
        "options":{
          "json": true
        }
      }
    ]
  }
}
```

Given the received data:

```json
[
  {
    "code":"foo"
  },
  {
    "code":"bar"
  }
]
```

Applying the given filter `?filter[where][code]=foo`, the result will be:

```json
[
  {
    "code":"foo"
  }
]
```


### next, previous and fork hooks

Another `bautajs` cool feature are hooks. Modify and add new behaviours before/after the data is being requested/received. 
Also it accepts to fork the request chain to process hooks in parallel.
See full examples on [Next][110], [Fork][111] and [Previous][105]


### API versioning

The `bautajs` has API versioning out of the box to version the services and datasources easily.

### API definition

The API definition is where are defined API versions, see [./lib/validators/api-definition-schema.json][112]

### Example

This is an example of API definitions for two API versions:

```json
[
  {
    "versionId": "v1",
    "swagger": "2.0",
    "apiVersion": "1.0",
    "info": {
      "description": "A new API",
      "version": "1.0.0",
      "title": "CORE API"
    },
    "basePath": "/v1/api/"
  },
  {
    "versionId": "v2",
    "swagger": "2.0",
    "apiVersion": "2.0",
    "info": {
      "description": "A new API",
      "version": "1.0.0",
      "title": "CORE API"
    },
    "basePath": "/v2/api/"
  }
]
```

API versions are accesible by code too:

```js
const { services } = require('bautajs');

services.cats.v1.find.exec();
services.cats.v2.find.exec();
```

In this example the `cats.v2` is inheriting automatically the behaviour of `cats.v1`

### Example of no inheritance

This is an example of API definitions for two API versions without inheritance:

```json
[
  {
    "versionId": "v1",
    "swagger": "2.0",
    "apiVersion": "1.0",
    "info": {
      "description": "A new API",
      "version": "1.0.0",
      "title": "CORE API"
    },
    "basePath": "/v1/api/"
  },
  {
    "versionId": "v2",
    "swagger": "2.0",
    "apiVersion": "2.0",
    "info": {
      "description": "A new API",
      "version": "1.0.0",
      "title": "CORE API"
    },
    "basePath": "/v2/api/",
    "noInheritance":{
      "cats":["find"]
    }
  }
]
```

Then the two versions will have a different behaviour:

```js
const { services } = require('bautajs');

services.cats.v1.find.exec();
services.cats.v2.find.exec(); // The result of this will be different from the v1
```

### Example of different datasources by version

This is an example of API definitions for two API versions without inheritance:

```json
[
  {
    "versionId": "v1",
    "swagger": "2.0",
    "apiVersion": "1.0",
    "info": {
      "description": "A new API",
      "version": "1.0.0",
      "title": "CORE API"
    },
    "basePath": "/v1/api/"
  },
  {
    "versionId": "v2",
    "swagger": "2.0",
    "apiVersion": "2.0",
    "info": {
      "description": "A new API",
      "version": "1.0.0",
      "title": "CORE API"
    },
    "basePath": "/v2/api/"
  }
]
```

This will be the datasource for the different versions:

```json
{
  "cats":{
    "operations":[
      {
        "name":"find",
        "url":"http://google.es"
      },
      {
        "name":"find",
        "url":"http://facebook.es",
        "versionId":"v2"
      }
    ]
  }
}
```

So as you can see here the v1 `cats.find` will fetch the data from google.es and v2 will fetch data from facebook.com.
Datasources without `versionId` will be applied to all the API versions. Also, `versionId` must match with the API definition `versionId`.


### Set an Operation schema (endpoint schema)

bautajs provides the way to associate an [OPENAPI][113] definition to one operation. Later this
will have multiple uses:

-   As an input validation if the option validateRequest is set to true or if the `this.validate()` function is called inside the loader.
-   To expose the service through an API endpoint.
-   To add the endpoint on the swagger explorer
-   Your imagination ;)

Take in account you can access to the definitions set when you create the bautajs instance on your API definition under definions field, that way
you are hable to share schema definitions between operation schemas.

Example:
my-schema.json

```json
  {
    "/cats/{catId}": {
      "get": {
        "tags": ["cats"],
        "summary": "Get cats by id",
        "parameters": [
          {
            "in": "path",
            "name": "catId",
            "required": true,
            "type": "string",
            "description": "The identifier of the cat"
        ],
        "operationId": "get-cats-catsId",
        "produces": ["application/json"],
        "responses": {
          "201": {
            "schema": {
              "$ref": "#/definitions/Cat"
            }
          },
          "401": {
            "description": "Not authorized",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "422": {
            "description": "Unprocessable entity",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "500": {
            "description": "Internal server error.",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        }
      }
    }
  }
```

some-loader.js

```js
  const mySchema = require('./my-schema.json')
  module.exports = (services) => {
      services.myService.v1.find.setSchema(mySchema)
  }
```


## Public API




### services

A services dictionary containing all the built services

Type: [Object][114]&lt;[string][115], [Service][116]>

#### Examples

```javascript
const { services } = require('bautajs');

services.cats.v1.find.next(someAfterHook);

const myContext = {};
const result = await services.cats.v1.find.exec(myContext);
```

### requireAll

Require a bunch of files that matches the given [glob][117] path.

#### Parameters

-   `folder` **([string][115] \| [Array][118]&lt;[string][115]>)** the given folder magic path, see [https://github.com/isaacs/node-glob][117]
-   `execute` **[boolean][119]** execute the required files with the given vars if they are functions (optional, default `true`)
-   `vars` **[Object][114]?** optional variables to add as a parameter on the file execution

#### Examples

```javascript
const { requireAll } = require('bautajs');

const files = requireAll('./my/path/to/datasources/*.js', true, {someVar:123});
```

Returns **[Array][118]&lt;any>** array of required files

### store

A store instance, use it to add global instances accesible from every where on your app.

Type: [Map][120]

#### Examples

```javascript
// fileA.js
const { store } = require('bautajs');

const myInstance = newInstance();

store.set('myInstance', myInstance);

// fileb.js
const { store } = require('bautajs');

const myInstance = store.get('myInstance');
```

### batuajs

Build the BautaJS services with the given dataSources and loaders.
This services could be accessible from { services } = require('bautajs'); after the initialization.

#### Parameters

-   `config` **[Object][114]** Your current envionment or static configuration, this will be injected into dataSource render time.
-   `apiDefinitions` **[Array][118]&lt;[Object][114]>** An array of [OpenAPI 3.0][121] definitions. See the valid schema @see [./lib/validators/api-definition-schema-json][122].
-   `options`   (optional, default `{}`)

#### Examples

```javascript
const bautajs = require('bautajs');
const config = {
  someProp: 'someVal'
};

bautajs(config, {
 // Load all the files with datasource in the file name
 dataSourcesPath: './services/*-datasource.?(js|json)',
 loadersPath:  './services/*-loaders.js'
});

// Assuming we have a dataSource for cats, once bautajs is initialized, you can execute the operation with the following code:
await bautajs.services.cats.v1.find.exec({});
```

### deref

Replace the $ref from the schema with the equivalent definition recursively

#### Parameters

-   `schema` **[Object][114]** the shcema to deref
-   `definitionsSchema` **[Object][114]** the definitions of the schema

Returns **[Object][114]** the given schema with the $ref replaced

### Artifacts

A set of artifacts that bautajs provides when use its public API


#### Operation

An operation can be translated as an datasource function that can be used
every where to execute a flow of loaders and hooks.

##### Parameters

-   `steps` **[Array][118]&lt;[function][123]>** an array of steps to add to the operation
-   `dataSourceTemplate` **[Object][114]** the operation datasource template definition, contains all the request data
-   `apiDefinition` **[Object][114]** An [OpenAPI][101] definition.
-   `optionals` **[Object][114]?** optional stuff
    -   `optionals.schema` **[Object][114]?** the [OpenAPI][101] schema specification for this operation. Can have $ref to the api-definition.json file @see [../../api-definition.json][124]
    -   `optionals.serviceName` **[Object][114]?** the service name of the operation, only used for log purposes

##### addMiddleware

Set a middleware before all the other hooks and loader. You can add as many as you want. The step will be added as the first executable function.
`MW2(new) -> MW1 -> P1 -> P2-> Loader -> N1 -> N2`
`Carefully do not use arrow functions if you want to access to the middleware this context`
The difference between this and the previus hooks are that this could be used at a service level as a previus step before all other hooks.

###### Parameters

-   `step` **any** the step to add to the first index of steps queue. It's a function that receives
    the middleware step result and returns a promise, a value or a callback

###### Examples

```javascript
const { services } = require('bautajs');

// Middleware step can be a function that returns a promise
services.cats.v1.find.addMiddleware((previousValue) => Promise.resolve('myValue'));
// Middleware step can be a function that returns a value
services.cats.v1.find.addMiddleware((previousValue) => 'value');
// Middleware step can be a function that returns a callback
services.cats.v1.find.addMiddleware((previousValue, done) => done(null, 'myValue'));
// Middleware step can be a value
services.cats.v1.find.addMiddleware('value');
// Middlewares can be chained, keep the order of execution as the declaration order.
services.cats.v1.find.addMiddleware((previousValue, done) => {
 // previousValue = 'value1';
 return done(null, previousValue);
}).addMiddleware('value1')
```

Returns **[Operation][125]** An instance of the operation

##### dataSource

###### Properties

-   `dataSource` **[Object][114]** the original operation datasource. Call this.dataSource(context) to get the compiled datasource template with the given context

##### definitions

###### Properties

-   `definitions` **[Object][114]** operation OpenAPI definitions

##### exec

Executes the current operation flow with the given context and initial data
The dataSource is only compiled on the loader step\`

###### Parameters

-   `req` **[Object][114]** the context of the operation, usually the req object
-   `initialData` **[Object][114]** the initial data to execute the first flow step (optional, default `{}`)

###### Examples

```javascript
const { services } = require('bautajs');
const express = require('express');
const app = express();

app.get('/blue', (req,res next) => {
 services.cats.v1.find.exec(req).then((value) =>next(null, value)).catch(next);
})
```

Returns **[Promise][126]&lt;([Array][118]&lt;[object][114]> | [object][114]), [Error][127]>** resolves with the flow execution value, rejects with the flow execution error

##### exposeOperation

Expose the operation to the API of the selected framework. By using this instead of the framwork native, allows you to use async await
on the frameworks that do not accept them and API versioning. To use this feature you need to use bautaJS through a bautajs frameworks plugin

###### Examples

```javascript
const { services } = require('bautajs');

services.myCustomService.apiVersionId.myCustomOperation.exposeOperation();
```

##### fork

Set a parallel flow in to your operation flow that resolves all the next steps in parallel

###### Parameters

-   `iterable` **([function][123] \| [Array][118]&lt;[object][114]> | [Array][118]&lt;[string][115]> | [Array][118]&lt;[number][128]>)** an iterable function that returns an array of values or an array of values

###### Examples

```javascript
const { services } = require('bautajs');

services.cats.v1.find.fork(['value1','value2'])
// The next hooks will be executed in parallel for value1 and value2 separately
.next((previousValue) =>{
// previousValue = 'value1'
 return previousValue
})
// This will merge the two streams
.join()
.next((previousValue) => {
// previousValue = ['value1','value2'];

return previousValue
})
```

Returns **[Operation][125]** An instance of the operation

##### join

Join the fork stream to the parent flow chain

Returns **[Operation][125]** An instance of the operation

##### next

Set a after loader hook. You can add as many as you want. The step will be added at the tail
of the next steps queue.
`P1 -> P2 -> Loader -> N1 -> N2 -> N3(new)`
`Carefully do not use arrow functions if you want to access to the loader this context`

###### Parameters

-   `step` **any** the step to execute at the tail of the next steps queue. It's a function that receives
    the previous step result and returns a promise, a value or a callback

###### Examples

```javascript
const { services } = require('bautajs');

// next step can be a function that returns a promise
services.cats.v1.find.next((previousValue) => Promise.resolve('myValue'));
// next step can be a function that returns a value
services.cats.v1.find.next((previousValue) => 'value');
// next step can be a function that returns a callback
services.cats.v1.find.next((previousValue, done) => done(null, 'myValue'));
// next step can be a value
services.cats.v1.find.next('value');
// Hooks can be chained.
services.cats.v1.find.next('value1').next((previousValue, done) => {
 // previousValue = 'value1';
 return done(null, previousValue)
}).next('value1')
```

Returns **[Operation][125]** An instance of the operation

##### parametersSchema

##### previous

Set a before loader hook. You can add as many as you want. The step will be added at the tail
of the previous steps queue.
`P1 -> P2 -> P3(new) -> Loader -> N1 -> N2`
`Carefully do not use arrow functions if you want to access to the loader this context`

###### Parameters

-   `step` **any** the step to add to the previous steps queue. It's a function that receives
    the previous step result and returns a promise, a value or a callback

###### Examples

```javascript
const { services } = require('bautajs');

// Previous step can be a function that returns a promise
services.cats.v1.find.previous((previousValue) => Promise.resolve('myValue'));
// Previous step can be a function that returns a value
services.cats.v1.find.previous((previousValue) => 'value');
// Previous step can be a function that returns a callback
services.cats.v1.find.previous((previousValue, done) => done(null, 'myValue'));
// Previous step can be a value
services.cats.v1.find.previous('value');
// Hooks can be chained, keep the order of execution as the declaration order.
services.cats.v1.find.previous((previousValue, done) => {
 // previousValue = 'value1';
 return done(null, previousValue);
}).previous('value1')
```

Returns **[Operation][125]** An instance of the operation

##### run

Run the steps chain from the given step index

###### Parameters

-   `index` **[number][128]** the step index
-   `value` **[Object][114]** the value to send to the step
-   `context` **[Object][114]** the context to send to the step

Returns **[Promise][126]&lt;([Array][118]&lt;[object][114]> | [object][114]), [Error][127]>** resolves with the step execution value, rejects with the step execution error

##### runFork

Run the given fork chain

###### Parameters

-   `fork` **[Fork][129]** a fork instance
-   `chain` **[Operation][125]** the fork chain of steps
-   `value` **[Object][114]** the last step values
-   `context`  

Returns **[Promise][126]&lt;[Array][118]&lt;[object][114]>, [Error][127]>** resolves with the array of values from the given fork execution, reject with the fork error execution

##### schema

##### serviceName

###### Properties

-   `serviceName` **[Object][114]** the service name that this operation belongs

##### setErrorHandler

Set a custom error handler that will be executed in case of some loader is rejected

###### Parameters

-   `errorHandler` **[function][123]** the error handler function

###### Examples

```javascript
const { services } = require('bautajs');

services.cats.v1.find.setErrorHandler((err) => Promise.reject(err));
```

Returns **[Operation][125]** An instance of the operation

##### setLoader

Set a custom loader for the operation.
`This will keep the steps chain order previously created.`
`Carefully do not use arrow functions if you want to access to the loader "this" context`
`The req object updates in this phase can not be getted from the datasource`

###### Parameters

-   `loader` **any** the loader function, value or class

###### Examples

```javascript
const { services } = require('bautajs');

// Loader can be a function that returns a promise
services.cats.v1.find.setLoader((previousValue) => Promise.resolve('myValue'));
// Loader can be a function that returns a value
services.cats.v1.find.setLoader(function(previousValue){
 const req = this.req;
 return 'value';
});
// Loader can be a function that returns a callback
services.cats.v1.find.setLoader((previousValue, done) => done(null, 'myValue'));
// Loader can be a value
services.cats.v1.find.setLoader('value');
```

Returns **[Operation][125]** an instance of the operation

##### setSchema

Override the operation schema

###### Parameters

-   `schema` **[Object][114]** the [OpenAPI][101] path schema @see [https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#paths-object-example][130]

###### Examples

```javascript
const { services } = require('bautajs');
conmst mySchema = require('./some-schema.json');

services.cats.v1.find.setSchema(mySchema);
```

Returns **[Operation][125]** An instance of the operation

##### validate

Allows to validate the given request againts the operation schema

###### Parameters

-   `req` **[Object][114]** the nodejs request (optional, default `{}`)
    -   `req.body` **[Object][114]?** The request body
    -   `req.query` **[Object][114]?** The request query params

###### Examples

```javascript
const { services } = require('bautajs');

services.myCustomService.v1.find.previous(function prev() => {
 const error = this.validate(this.req);
 if(error){
  throw error;
 }
})
```

Returns **([Error][127] | null)** A T400 error is returned for an not valid body json

#### Fork

A fork instance is a sub chain of steps that run in parallel inside the current chain

##### Parameters

-   `iterable` **([function][123] \| [Array][118]&lt;any>)** an iterable function that returns an array of values or an array of values

##### initIterator

Initialize the fork iterator, the limit items for the iterable is 20

###### Parameters

-   `context` **[Object][114]** the given context of the flow
-   `value` **[Object][114]** the last value before the fork


-   Throws **[Error][127]** if the fork limit is reached or the iterator is not valid

##### nextValue

Get the next value of the iterator

Returns **(null | any)** the next iterator value

#### Step

An Step instance is the representation of a function or a value. Is the smallest item of the chain.
The step gets as parameter the context and the previous step value and returns a promise a value or a callback.

##### Parameters

-   `step` **[function][123]** a function that returns a promise
-   `type` **[String][115]** represents the type of the operation (loader, next, previous, join, fork)

##### handleValue

Return the step as a promise

###### Parameters

-   `value` **[Object][114]** the input value to send as a result

Returns **[Promise][126]&lt;([Array][118]&lt;[object][114]> | [object][114]), [Error][127]>** resolves with the step result, rejects with the step error

##### run

Run the step binding the given context and adding the given value, making accessible the context (req) by 'this'
inside the step function.
The step always returns a promise, but inside the step function you can return a value, promise or a callback.

###### Parameters

-   `context` **[Object][114]** the context bind to the step execution
-   `value` **[Object][114]** the input value to send to the step execution

##### runWithCallback

Execute the step and convert the callback returned into a promise

###### Parameters

-   `context` **[Object][114]** the context bind to the step execution
-   `value` **[Object][114]** the input value to send to the step execution

Returns **[Promise][126]&lt;([Array][118]&lt;[object][114]> | [object][114]), [Error][127]>** resolves with the step result, rejects with the step error

##### runWithReturn

Execute the step and covnert the simple result returned into a promise

###### Parameters

-   `context` **[Object][114]** the context bind to the step execution
-   `value` **[Object][114]** the input value to send to the step execution

Returns **[Promise][126]&lt;([Array][118]&lt;[object][114]> | [object][114]), [Error][127]>** resolves with the step result, rejects with the step error

#### Service

The Service is a set of [Version][92]

Type: [Object][114]

##### Parameters

-   `serviceName` **[string][115]** the service name
-   `datasourceTemplate` **[Object][114]** a dictionary of services with his operations @see [../validators/datasource-schema.json][131]
-   `apiDefinitions` **[Array][118]&lt;[Object][114]>** Array of [OpenAPI][101] definitions.
-   `optionals` **[Object][114]?** optional stuff

#### Version

The Version is a set of [Operation][31]

Type: [Object][114]

##### Parameters

-   `versionName` **[string][115]** the version name

##### addMiddleware

Set a middleware before all the operations of the given version service. You can add as many as you want. The step will be added as the first executable function.
`MW2(new) -> MW1 -> P1 -> P2-> Loader -> N1 -> N2`
`Carefully do not use arrow functions if you want to access to the middleware this context`

###### Parameters

-   `middleware` **any** A function to add to all the version operations chain. It's a function that receives
    a previous middleware step result and returns a promise, a value or a callback

###### Examples

```javascript
const { services } = require('bautajs');

// Middleware step can be a function that returns a promise
services.cats.v1.addMiddleware((previousValue) => Promise.resolve('myValue'));
// Middleware step can be a function that returns a value
services.cats.v1.addMiddleware((previousValue) => 'value');
// Middleware step can be a function that returns a callback
services.cats.v1.addMiddleware((previousValue, done) => done(null, 'myValue'));
// Middleware step can be a value
services.cats.v1.addMiddleware('value');
// Middlewares can be chained, keep the order of execution as the declaration order.
services.cats.v1.addMiddleware((previousValue, done) => {
 // previousValue = 'value1';
 return done(null, previousValue);
}).addMiddleware('value1')
```

Returns **[Version][132]** An instance of the version

##### addOperation

Create a new operation for the given version service. It is recomended to declare operations from the datasource and not using this method!

###### Parameters

-   `name` **[string][115]** The operation name
-   `operation` **[Operation][125]** The operation instance

###### Examples

```javascript
const { services, Operation } = require('bautajs');
const dataSourceTemplate = {
 name: 'find'
}
const apiDefinition = {
 versionId:"v1",
 openapi: "3.0",
 info: {
   title:"version 1",
   version: "1.0"
 }
}
const operation = new Operation([() => 'hellow world'], dataSourceTemplate, apiDefinition, { serviceName: 'cats' })

services.cats.v1.addOperation(dataSourceTemplate.name, operation);
```

Returns **[Version][132]** An instance of the version

[1]: #bautajs

[2]: #how-to-install

[3]: #usage

[4]: #features

[5]: #store

[6]: #config

[7]: #request-validation

[8]: #datasources

[9]: #multipartrelated-requests

[10]: #multipartform-data-requests

[11]: #request-like-features

[12]: #debug

[13]: #loopbackfilters

[14]: #next-previous-and-fork-hooks

[15]: #api-versioning

[16]: #set-an-operation-schema-endpoint-schema

[17]: #public-api

[18]: #services

[19]: #examples

[20]: #requireall

[21]: #parameters

[22]: #examples-1

[23]: #store-1

[24]: #examples-2

[25]: #batuajs

[26]: #parameters-1

[27]: #examples-3

[28]: #deref

[29]: #parameters-2

[30]: #artifacts

[31]: #operation

[32]: #parameters-3

[33]: #addmiddleware

[34]: #parameters-4

[35]: #examples-4

[36]: #datasource

[37]: #properties

[38]: #definitions

[39]: #properties-1

[40]: #exec

[41]: #parameters-5

[42]: #examples-5

[43]: #exposeoperation

[44]: #examples-6

[45]: #fork

[46]: #parameters-6

[47]: #examples-7

[48]: #join

[49]: #next

[50]: #parameters-7

[51]: #examples-8

[52]: #parametersschema

[53]: #previous

[54]: #parameters-8

[55]: #examples-9

[56]: #run

[57]: #parameters-9

[58]: #runfork

[59]: #parameters-10

[60]: #schema

[61]: #servicename

[62]: #properties-2

[63]: #seterrorhandler

[64]: #parameters-11

[65]: #examples-10

[66]: #setloader

[67]: #parameters-12

[68]: #examples-11

[69]: #setschema

[70]: #parameters-13

[71]: #examples-12

[72]: #validate

[73]: #parameters-14

[74]: #examples-13

[75]: #fork-1

[76]: #parameters-15

[77]: #inititerator

[78]: #parameters-16

[79]: #nextvalue

[80]: #step

[81]: #parameters-17

[82]: #handlevalue

[83]: #parameters-18

[84]: #run-1

[85]: #parameters-19

[86]: #runwithcallback

[87]: #parameters-20

[88]: #runwithreturn

[89]: #parameters-21

[90]: #service

[91]: #parameters-22

[92]: #version

[93]: #parameters-23

[94]: #addmiddleware-1

[95]: #parameters-24

[96]: #examples-14

[97]: #addoperation

[98]: #parameters-25

[99]: #examples-15

[100]: https://axags.jfrog.io/axags/api/npm/virtual-bcn-node/

[101]: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#specification

[102]: https://github.com/sindresorhus/got

[103]: ./lib/validators/datasource-schema.json

[104]: https://github.com/datavis-tech/json-templates

[105]: /#previous

[106]: https://github.com/request/request#multipartrelated

[107]: https://github.axa.com/Digital/bauta-nodejs/tree/master/packages/multipart-request-builder

[108]: https://github.com/pinojs/pino/blob/master/docs/redaction.md

[109]: https://loopback.io/doc/en/lb3/Querying-data.html

[110]: /#next

[111]: /#fork

[112]: ./lib/validators/api-definition-schema.json

[113]: https://github.com/OAI/OpenAPI-Specification

[114]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object

[115]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String

[116]: #service

[117]: https://github.com/isaacs/node-glob

[118]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array

[119]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean

[120]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map

[121]: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md

[122]: ./lib/validators/api-definition-schema-json

[123]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function

[124]: ../../api-definition.json

[125]: #operation

[126]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise

[127]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Error

[128]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number

[129]: #fork

[130]: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#paths-object-example

[131]: ../validators/datasource-schema.json

[132]: #version
