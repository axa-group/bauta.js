toc:
  - name: bautajs
    description: |
      A library to build easy versionable and self organized middlewares.
  - name: How to install
    description: |
      Make sure that you have access to [Artifactory](https://axags.jfrog.io/axags/api/npm/virtual-bcn-node/)
      ```console
        npm install bautajs
      ```
  - name: Usage
    description: |
      To use bautaJS with the default configuration we will need to create the following folder structure:
        - server
          - services
            - v1
              - cats
                  - cats-datasource.json
                  - cats-loader.js
                  - cats-schema.json
          - server.js
          - api-definitions.json

      // cats-datasource.json
      ```json
      {
        "cats": {
          "operations": [
            {
              "name": "find",
              "url": "{{config.endpoint}}/getsome"
            }
          ]
        }
      }
      ```

      // cats-loader.js
      ```js
        const catsSchema = require('./cats-schema.json');

        module.exports = services => {
          services.cats.v1.find
            .setSchema(catsSchema)
            .setLoader(function catLoaders(){
              this.req.logger.info('Fetching some cats');

              return this.dataSource.request();
            })
        };
      ```

      // cats-schema.json
      ```json
        {
          "/cats": {
            "get": {
              "tags": ["cats"],
              "summary": "Get the list of cats",
              "operationId": "get-cats",
              "produces": ["application/json"],
              "responses": {
                "200": {
                  "description": "successful operation",
                  "schema": {
                    "type": "array",
                    "items": {
                      "type": "Object",
                      "properties": {
                        "name": {
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
      ```

      // api-definitions.json
      ```json
        [
          {
            "versionId": "v1",
            "openapi": "3.0",
            "apiVersion": "1.0",
            "swaggerVersion": "1.0",
            "info": {
              "description": "API for cool cats",
              "version": "1.0.0",
              "title": "MyAXA API"
            },
            "basePath": "/v1/api/"
          }
        ]
      ```

      // server.js
      ```js
          const bautaJS = require('bautajs');
          const apiDefinitions = require('./api-definitions.json');
          
          const config = {
            endpoint:'http://coolcats.com'
          }

          bautaJS(config, apiDefinitions);

          await bautaJS.services.cats.v1.find.exec({});
      ```

      This will produce a request to `coolcats.com` with the result:
        ```json
          [
            {
              "name": "cat1"
            }
          ]
        ```
  - name: Features
    children:
      - name: Request Validation
        description: |
          `bautajs` comes with a default request validation using the [openAPI schema](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#specification). By default, it is set to true.
          This feature is always enabled while you have a valid openAPI schema inputs. To disable it for one endpoint just add validateRequest to false inside the path definition.

          ### Example
           
            This is a path schema example:
            
            ```json
            {
              "/test":{
                "get":{
                  "validateRequest": false,
                  "parameters": [
                  {
                    "name": "limit",
                    "in": "query",
                    "description": "How many items to return at one time (max 100)",
                    "required": false,
                    "schema": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                 ]
                }
              }
            }
            ```

            Alternative you can also validate inside every resolver by accesing to the context `ctx.validate()`.
            
            ```js
              services.cats.v1.find.push(function pFn(_, ctx) {
                const error = ctx.validate();
                if(error) {
                  throw error;
                }
              })
            ```
      - name: datasources
        description: |
          The datasources are the main feature of the library. The dataSources define how the services will behave and from where the data will come.
          ### Define a datasource

          To define a datasource, create a file into `"services/"` folder with a name ending on `"-datasource.json|js"`. The datasources are loaded automatically by the `bautajs` in bootstrap time.
          A datasource containing a `url` property on its definition, represents a HTTP request (using [Got](https://github.com/sindresorhus/got)).           

          `By default request are done using [keepAlive](https://nodejs.org/api/http.html#http_new_agent_options)`

          Without `url`, a datasource just describe an simple service operation.

          ### Datasource structure
          `bautajs` datasources must be compliant with {@link ./lib/validators/datasource-schema.json}.

          ### Example

          This is a datasource example:

          ```json
          {
            "testService":{
              "operations":[
                {
                  "name":"test",
                  "url":"http://myserver.com",
                  "options":{
                    "json": true,
                    "headers": {
                      "Accept":"application-json"
                    }
                  }
                }
              ]
            }
          }
          ```

          ### Dynamic datasources

          Datasources used in every request are compiled on demand. It allow to add dynamic information into them, specifying properties from `req`, `config` and `env` (environment variables) objects. 
          See the template syntax format at [stjs](https://www.npmjs.com/package/stjs).
          to retrieve dynamic data.

          ```json
          {
            "testService":{
              "operations":[
                {
                  "name":"test",
                  "url":"{{config.url}}",
                  "options":{
                    "json": true,
                    "headers": {
                      "Accept-Language": [{
                        "{{#if !req.headers.accept-language}}": "my default lang",
                        "{{#else}}":"{{req.headers.accept-language}}"
                      }]",
                      "x-axa-user-agent": "{{req.headers.x-axa-user-agent}}"
                    }
                  }
                }
              ]
            }
          }
          ```
          `Once the dynamic data is resolved, the fields with `undefined` or `null` values, are removed from the request as [got definitions](https://github.com/sindresorhus/got).

          ### Accessing compiled datasources from my resolvers (steps)

          Is possible to access to compiled datasources from the operations resolvers.

          ```js
            const compileDataSource = require('bautajs/decorators/compile-datasource');

            // Launching the operation datasource request.
            services.cats.v1.find.push(compileDataSource((_, ctx) => {
              return ctx.dataSource.request();
            }));
            // Launching the operation datasource request with custom option.
            // They will be merged with the definition options.
            services.cats.v1.find.push(compileDataSource((_, ctx) => {
              const customOptions = { json: false };
              return ctx.dataSource.request(customOptions);
            }));
          ````

          ```js
            // Launching other operation datasource request
            services.cats.v1.find.push((_, ctx) => {
              return services.documents.v1.find.dataSource(ctx.req).request();
            });
          ````

          By default, `bautajs`, uses [got](https://github.com/sindresorhus/got) library to launch the operation datasources requests.
          However, is possible to use your preferred request module using the datasources definitions.
          ```js
            const compileDataSource = require('bautajs/decorators/compile-datasource');
            const request = require('request');

            services.cats.v1.find.push(compileDataSource(_, ctx, cb) =>{
              const { method, url, options } = ctx.dataSource;

              return request({ method, url, ...options }, cb);
            }));
          ````

      - name: multipart/related requests
        description: |
          [got](https://github.com/sindresorhus/got) do not come with `multipart/related` out of the box.
          Thus, `bautajs` add it to be available at the operations datasources requests.
          `bautajs` follows the way [request/request](https://github.com/request/request#multipartrelated) implements `multipart/related` by using [multipart-request-builder](https://github.axa.com/Digital/bauta-nodejs/tree/master/packages/multipart-request-builder).

          ```text
            Do not add the multipart configuration in the operation datasource definition if it has streams (fs.createReadStream).
            It must be passed in the resolver definition
          ```

          ```json
          // my-datasource.json
          // multipart/related without streams
          {
            "testService": {
              "operations": Â [
                {
                  "name": "operation1",
                  "headers": {
                    "content-type": "multipart/related"
                  },
                  "preambleCRLF": true,
                  "postambleCRLF": true
                }
              ]
            }
          } 
          ```

          ```js
          const compileDataSource = require('bautajs/decorators/compile-datasource');
          // my-resolver.js
          // multipart/related with stream
          services.testService.v1.operation1.setLoader(compileDataSource((_, ctx) =>{
            return ctx.dataSource.request({
              multipart: [
                {
                  'content-type': 'application/json',
                  body: JSON.stringify({
                    foo: 'bar',
                    _attachments: {
                      'message.txt': {
                        follaws: true,
                        length: 18,
                        'content_type': 'text/plain'
                      }
                    }
                  })
                },
                {
                  body: 'I am an attachment'
                },
                {
                  body: fs.createReadStream('image.png')
                }
              ],
              // alternatively pass an object containing additional options multipart: {
              chunked: false,
              data: [
                {
                  'content-type': 'application/json',
                  body: JSON.stringify({
                    foo: 'bar',
                    _attachments: {
                      'message.txt': {
                        follows: true,
                        length: 18,
                        'content_type': 'text/plain'
                      }
                    }
                  })
                },
                {
                  body: 'I am an attachment'
                }
              ]
            }})
          }))
          ```

      - name: multipart/form-data requests
        description: |
          As for `multipart/related`, `bautajs` provides its own implementation for `multipart/form-data`.

          ```text
            Do not add the multipart configuration in the operation datasource definition if it has streams (fs.createReadStream).
            It must be passed in the resolver definition
          ```
          ```json
          // my-datasource.json
          // multipart/related without streams
          {
            "testService": {
              "operations": [
                {
                  "name": "operation1"
                }
              ]
          } 
          ```

          ```js
          // my-resolver.js
          // multipart/related with streams
          services.testService.v1.operation1.setLoader(compileDataSource((_, ctx) => {
            const formData = {
              // Pass a simple key-value pair
              my_field: 'my_value',
              // Pass data via Buffers
              my_buffer: Buffer.from([1, 2, 3]),
              // Pass data via Streams
              my_file: fs.createReadStream(__dirname + '/unicycle.jpg'),
              // Pass multiple values /w an Array
              attachments: [
                fs.createReadStream(__dirname + '/attachment1.jpg'),
                fs.createReadStream(__dirname + '/attachment2.jpg')
              ],
              // Pass optional meta-data with an 'options' object with style: {value: DATA, options: OPTIONS}
              // Use case: for some types of streams, you'll need to provide "file"-related information manually.
              // See the `form-data` README for more information about options: https://github.com/form-data/form-data
              file: {
                value:  fs.createReadStream('/file'),
                options: {
                  filename: 'someImage.jpg',
                  contentType: 'image/jpeg'
                }
              }
            };
            return ctx.dataSource.request({ formData });
          }));
          ```

      - name: Request like features
        description: |
          To help on the transition from `request` to `got`, there are some alias and helpfull fields that feels like still using request library:

          - Use 'json' as an object to POST json data (content-type: application/json):
          ```json
            {
              "json": {
                "someFiled":"someValue"
              }
            }
          ```
          - Use 'form' as an object to POST data as url encoded form (content-type:application/x-www-form-urlencoded):
          ```json
            {
              "form": {
                "someFiled":"someValue"
              }
            }
          ```

          - Custom `Agent` allowing the following features:
            - http_proxy and https_proxy environment variables
            - Request using custom certificates throught 'cert' and 'key' native NODEJS fields
            - StricSSL enable throught 'rejectUnauthorized' field

      - name: Debug
        description: |
          One of the main purpose of `bautajs` is provide a nice debugging experience. 
          The request options, the response body and the times a request takes are logged.
          To activate the logs just set debug:

          ```cmd
          LOG_LEVEL=debug DEBUG=bautajs*
          ```
          Furthemore, if you want to censor some words we strongly recomend use [pino redaction](https://github.com/pinojs/pino/blob/master/docs/redaction.md)

      - name: LoopbackFilters
        description: |
          The `bautajs` allows to use [loopback filters](https://loopback.io/doc/en/lb3/Querying-data.html) over arrays.
          Add the applyLoopbackFilters option to datasource operations:

          ### Example

          ```json
          {
            "testService":{
              "operations":[
                {
                  "name":"test",
                  "url":"http://myserver.com",
                  "applyLoopbackFilters": true,
                  "options":{
                    "json": true
                  }
                }
              ]
            }
          }
          ```

          Given the received data:

          ```json
          [
            {
              "code":"foo"
            },
            {
              "code":"bar"
            }
          ]
          ```

          Applying the given filter `?filter[where][code]=foo`, the result will be:

          ```json
          [
            {
              "code":"foo"
            }
          ]
          ```

      - name: API versioning
        description: |
          The `bautajs` has API versioning out of the box to version the services and datasources easily.

          ### API definition

          The API definition is where are defined API versions, see {@link ./lib/validators/api-definition-schema.json}

          ### Example

          This is an example of API definitions for two API versions:

          ```json
          // api-definitions.json
          [
            {
              "openapi": "3.0.0",
              "apiVersion": "1.0",
              "info": {
                "description": "A new API",
                "version": "v1",
                "title": "CORE API"
              },
              "servers": [
                {
                  "url":"/v1/api/"
               }
              ]
            },
            {
              "openapi": "3.0.0",
              "apiVersion": "2.0",
              "info": {
                "description": "A new API",
                "version": "v2",
                "title": "CORE API"
              },
              "servers": [
                {
                  "url":"/v1/api/"
               }
              ]
            }
          ]
          ```

          API versions are accesible by code too:
            
          ```js
          // my-resolver.js
          module.exports = (services) => {
            services.cats.v1.find.exec();
            services.cats.v2.find.exec();
          }
          ```

          In this example the `cats.v2` is inheriting automatically the behaviour of `cats.v1`

          ### Example of no inheritance

          This is an example of API definitions for two API versions without inheritance:

          - Using the previous example api-definitions.json, we can specify on the v2 data source what we don't want to inherit:
          ```json
          // v2-datasource.json
          {
            "cats": {
              "operations": [
                {
                  "id":"find",
                  "inherit": false
                }
              ]
            }
          }
          ```

          Then the two versions will have a different behaviour:

          ```js
          // my-resolver.js
          module.exports = (services) => {
            services.cats.v1.find.exec();
            services.cats.v2.find.exec(); // The result of this will be different from the v1
          }
          ```

          ### Example of different datasources by version

          This is an example of API definitions for two API versions without inheritance:

          This will be the datasource for the different versions:

          ```json
          {
            "cats":{
              "operations":[
                {
                  "name":"find",
                  "url":"http://google.es"
                },
                {
                  "name":"find",
                  "url":"http://facebook.es",
                  "version":"v2"
                }
              ]
            }
          }
          ```
          So as you can see here the v1 `cats.find` will fetch the data from google.es and v2 will fetch data from facebook.com.
          Datasources without `version` will be linked to the first api-definition version. Also, `version` must match with the API definition `info.version`.
      - name: Set an Operation schema (endpoint schema)
        description: |
          bautajs provides the way to associate an [OPENAPI](https://github.com/OAI/OpenAPI-Specification) definition to one operation. Later this
          will have multiple uses:
            - As an input validation if the option validateRequest is set to true or if the `this.validate()` function is called inside the resolver.
            - To expose the service through an API endpoint.
            - To add the endpoint on the swagger explorer
            - Your imagination ;)

          Take in account you can access to the definitions set when you create the bautajs instance on your API definition under definions field, that way
          you are hable to share schema definitions between operation schemas.

          Example:
          my-schema.json
          ```json
            {
              "/cats/{catId}": {
                "get": {
                  "tags": ["cats"],
                  "summary": "Get cats by id",
                  "parameters": [
                    {
                      "in": "path",
                      "name": "catId",
                      "required": true,
                      "type": "string",
                      "description": "The identifier of the cat"
                    }
                  ],
                  "operationId": "get-cats-catsId",
                  "produces": ["application/json"],
                  "responses": {
                    "201": {
                      "schema": {
                        "$ref": "#/definitions/Cat"
                      }
                    },
                    "401": {
                      "description": "Not authorized",
                      "schema": {
                        "$ref": "#/definitions/Error"
                      }
                    },
                    "422": {
                      "description": "Unprocessable entity",
                      "schema": {
                        "$ref": "#/definitions/Error"
                      }
                    },
                    "500": {
                      "description": "Internal server error.",
                      "schema": {
                        "$ref": "#/definitions/Error"
                      }
                    }
                  }
                }
              }
            }
          ```
          some-resolver.js
          ```js
            const mySchema = require('./my-schema.json')
            module.exports = (services) => {
                services.myService.v1.find.setSchema(mySchema)
            }

          ```
      - name: Using lodash FP functions
        description: |
          Lodash FP functions can be pushed to the execution chain.
          ```js
          // my-resolver.js
          const flow = require('lodash/fp/flow');
          const map = require('lodash/fp/map');
          const filter = require('lodash/fp/filter');
          const request = require('bautajs/decorators/request');

          module.export = (services) => {
            services.test.v1.op1
              .push(request)
              .push(flow(
                  map(['id':'myIdMapped']),
                  filter(['tag','dogs'])
                )
              )
            // Use it without flow (not recomended sice push will create a promise always)
            services.test.v1.op1
                .push(request)
                .push(map(['id':'myIdMapped']))
                .push(filter(['tag','dogs']))
          }

          ```
  - name: Decorators
    description: A set of decorators to be used as a helpers of your resolvers
    children:
      - name: Usage
        description: |
          To access to the decorators you just have to import them one by one:
          ```js
            const compileDataSource = require('bautajs/decorators/compile-datasource');

            services.v1.cats.op1.push(compileDataSource((_, ctx) => {
              return ctx.dataSource.request();
            }));
          ```
      - name: Create your own decorator
        description: |
          To create your own decorator just take in account that BautaJS push function will inject the previous value, the context(ctx) containing the req, res... and a done function.
          Example:
          ```js
            const Step = require('bautajs/core/Step');

            module.exports = fn => async (value, ctx) => {
              const step = new Step(fn);
              return step.run({ ...ctx, dataSource: ctx.dataSource(ctx.req) }, value);
            };
          ```
          Remember use Step to wrap the given function, it will helps on the managment of the Promise/callback/simple value usage.

      - request
      - compileDataSource
      - flow
      - template
      - parallel
  - name: Public API
    children:
      - BautaJS
      - name: Artifacts
        description: |
          A set of artifacts that bautajs provides when use its public API
        children:
          - Operation
          - Step
          - Service
          - Version
          - Logger
