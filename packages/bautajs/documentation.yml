toc:
  - name: bautajs
    description: |
      A library to build easy versionable and self organized middlewares.
  - name: How to install
    description: |
      Make sure that you have access to [Artifactory](https://axags.jfrog.io/axags/api/npm/virtual-bcn-node/)
      ```console
        npm install bautajs
      ```
  - name: Usage
    description: |
      To use bautaJS with the default configuration we will need to create the following folder structure:
        - server
          - services
            - v1
              - cats
                  - cats-datasource.json
                  - cats-loader.js
                  - cats-schema.json
          - server.js
          - api-definitions.json

      // cats-datasource.json
      ```json
      {
        "cats": {
          "operations": [
            {
              "name": "find",
              "url": "{{config.endpoint}}/getsome"
            }
          ]
        }
      }
      ```

      // cats-loader.js
      ```js
        const catsSchema = require('./cats-schema.json');

        module.exports = services => {
          services.cats.v1.find
            .setSchema(catsSchema)
            .setLoader(function catLoaders(){
              this.req.logger.info('Fetching some cats');

              return this.dataSource.request();
            })
        };
      ```

      // cats-schema.json
      ```json
        {
          "/cats": {
            "get": {
              "tags": ["cats"],
              "summary": "Get the list of cats",
              "operationId": "get-cats",
              "produces": ["application/json"],
              "responses": {
                "200": {
                  "description": "successful operation",
                  "schema": {
                    "type": "array",
                    "items": {
                      "type": "Object",
                      "properties": {
                        "name": {
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
      ```

      // api-definitions.json
      ```json
        [
          {
            "versionId": "v1",
            "openapi": "3.0",
            "apiVersion": "1.0",
            "swaggerVersion": "1.0",
            "info": {
              "description": "API for cool cats",
              "version": "1.0.0",
              "title": "MyAXA API"
            },
            "basePath": "/v1/api/"
          }
        ]
      ```

      // server.js
      ```js
          const bautaJS = require('bautajs');
          const apiDefinitions = require('./api-definitions.json');
          
          const config = {
            endpoint:'http://coolcats.com'
          }

          bautaJS(config, apiDefinitions);

          await bautaJS.services.cats.v1.find.exec({});
      ```

      This will produce a request to `coolcats.com` with the result:
        ```json
          [
            {
              "name": "cat1"
            }
          ]
        ```
  - name: Features
    children:
      - name: Store
        description: |
          `bautajs` provides a built-in 'Map' singleton. Add data and get data from everywhere.
          The singleton life is related to the life of the Node.js process. 

          ```js
            const { store } = require('bautajs');

            store.set('data', { foo: boo });

            const data = store.get('data');
          ```
      - name: Config
        description: |
          By default `bautajs` will add the configuration you send in the initialization moment into a global store. So you can access the config
          inside all the loaders by doing:

          ```js
            const { store } = require('bautajs');

            store.get('config');
          ```
      - name: Request Validation
        description: |
          `bautajs` comes with a default request validation using the [openAPI schema](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#specification). By default, it is set to false.
          By adding `validateRequest: true` on the operation datasource, request validation will be enabled.

          ### Example
           
            This is a datasource example:
            
            ```json
            {
              "testService":{
                "operations":[
                  {
                    "name":"test",
                    "url":"http://myserver.com",
                    "validateRequest": true
                  }
                ]
              }
            }
            ```

            Alternative you can also validate inside every loader by accesing to the context `this.validate(this.req)` sending a req body or query.
            
            ```js
              services.cats.v1.find.previous(function pFn() {
                const error = this.validate(this.req);
                if(error) {
                  throw error;
                }
              })
            ```
      - name: datasources
        description: |
          The datasources are the main feature of the library. The dataSources define how the services will behave and from where the data will come.
          ### Define a datasource

          To define a datasource, create a file into `"services/"` folder with a name ending on `"-datasource.json|js"`. The datasources are loaded automatically by the `bautajs` in bootstrap time.
          A datasource containing a `url` property on its definition, represents a HTTP request (using [Got](https://github.com/sindresorhus/got)).           

          `By default request are done using [keepAlive](https://nodejs.org/api/http.html#http_new_agent_options)`

          Without `url`, a datasource just describe an simple service operation.

          ### Datasource structure
          `bautajs` datasources must be compliant with {@link ./lib/validators/datasource-schema.json}.

          ### Example

          This is a datasource example:

          ```json
          {
            "testService":{
              "operations":[
                {
                  "name":"test",
                  "url":"http://myserver.com",
                  "options":{
                    "json": true,
                    "headers": {
                      "Accept":"application-json"
                    }
                  }
                }
              ]
            }
          }
          ```

          ### Dynamic datasources

          Datasources used in every request are compiled on demand. It allow to add dynamic information into them, specifying properties from `req`, `config` and `env` (environment variables) objects. 
          See the template syntax format at [json-templates](https://github.com/datavis-tech/json-templates).
          to retrieve dynamic data.

          ```json
          {
            "testService":{
              "operations":[
                {
                  "name":"test",
                  "url":"{{config.url}}",
                  "options":{
                    "json": true,
                    "headers": {
                      "Accept-Language": "{{req.headers.accept-language:ES_es}}",
                      "x-axa-user-agent": "{{req.headers.x-axa-user-agent:My default user agent}}"
                    }
                  }
                }
              ]
            }
          }
          ```
          `Once the dynamic data is resolved, the fields with `undefined` or `null` values, are removed from the request as [got definitions](https://github.com/sindresorhus/got).

          ### Accessing compiled datasources from loader

          Is possible to access to compiled datasources from the operations loaders.

          ```js
            // Launching the operation datasource request.
            services.cats.v1.find.setLoader(function myLoader() {
              return this.dataSource.request();
            });
            // Launching the operation datasource request with custom option.
            // They will be merged with the definition options.
            services.cats.v1.findById.setLoader(function myLoader() {
              const customOptions = { json: false };
              return this.dataSource.request(customOptions);
            });
          ````

          ```js
            // Launching other operation datasource request
            services.cats.v1.find.setLoader(function myLoader() {
              return services.documents.v1.find.dataSource(this.req).request();
            });
          ````

          By default, `bautajs`, uses [got](https://github.com/sindresorhus/got) library to launch the operation datasources requests.
          However, is possible to use your preferred request module using the datasources definitions.
          ```js
            const request = require('request');
            services.cats.v1.find.setLoader(function myLoader(cb){
              const { method, url, options } = services.dogs.v1.find.dataSource(this.req);

              return request({ method, url, ...options }, cb);
            });
          ````

          ### Accessing a datasource from previous and middleware hooks

          Accessing from a `previous` hook (see [Previous](/#previous)) the datasource is not compiled yet. 
          Is possible to add/modify datasources template options (e.g. headers) on the previous hooks.
           
          On the other hand, is possible to compile the operation datasource in a previous hook. 
          Even that, it will be compiled again on the loader phase as well.

          ```js
              services.cats.v1.previous(function prev() {
                const compiled = this.dataSource({req:this.req});
                // do something with compiled
              })
          ```

      - name: multipart/related requests
        description: |
          [got](https://github.com/sindresorhus/got) do not come with `multipart/related` out of the box.
          Thus, `bautajs` add it to be available at the operations datasources requests.
          `bautajs` follows the way [request/request](https://github.com/request/request#multipartrelated) implements `multipart/related` by using [multipart-request-builder](https://github.axa.com/Digital/bauta-nodejs/tree/master/packages/multipart-request-builder).

          ```text
            Do not add the multipart configuration in the operation datasource definition if it has streams (fs.createReadStream).
            It must be passed in the loader definition
          ```

          ```json
          // my-datasource.json
          // multipart/related without streams
          {
            "testService": {
              "operations":  [
                {
                  "name": "operation1",
                  "headers": {
                    "content-type": "multipart/related"
                  },
                  "preambleCRLF": true,
                  "postambleCRLF": true
                }
              ]
            }
          } 
          ```

          ```js
          // my-loader.js
          // multipart/related with stream
          services.tstService.v1.operation1.setLoader(function loader(){
            return this.dataSource.requests({
              multipart: [
                {
                  'content-type': 'application/json',
                  body: JSON.stringify({
                    foo: 'bar',
                    _attachments: {
                      'message.txt': {
                        follaws: true,
                        length: 18,
                        'content_type': 'text/plain'
                      }
                    }
                  })
                },
                {
                  body: 'I am an attachment'
                },
                {
                  body: fs.createReadStream('image.png')
                }
              ],
              // alternatively pass an object containing additional options multipart: {
              chunked: false,
              data: [
                {
                  'content-type': 'application/json',
                  body: JSON.stringify({
                    foo: 'bar',
                    _attachments: {
                      'message.txt': {
                        follows: true,
                        length: 18,
                        'content_type': 'text/plain'
                      }
                    }
                  })
                },
                {
                  body: 'I am an attachment'
                }
              ]
            }})
          })
          ```

      - name: multipart/form-data requests
        description: |
          As for `multipart/related`, `bautajs` provides its own implementation for `multipart/form-data`.

          ```text
            Do not add the multipart configuration in the operation datasource definition if it has streams (fs.createReadStream).
            It must be passed in the loader definition
          ```



          ```json
          // my-datasource.json
          // multipart/related without streams
          {
            "testService": {
              "operations":  [
                {
                  "name": "operation1"
                }
              ]
          } 
          ```

          ```js
          // my-loader.js
          // multipart/related with streams
          services.testService.v1.operation1.setLoader(function loader(){
            const formData = {
              // Pass a simple key-value pair
              my_field: 'my_value',
              // Pass data via Buffers
              my_buffer: Buffer.from([1, 2, 3]),
              // Pass data via Streams
              my_file: fs.createReadStream(__dirname + '/unicycle.jpg'),
              // Pass multiple values /w an Array
              attachments: [
                fs.createReadStream(__dirname + '/attachment1.jpg'),
                fs.createReadStream(__dirname + '/attachment2.jpg')
              ],
              // Pass optional meta-data with an 'options' object with style: {value: DATA, options: OPTIONS}
              // Use case: for some types of streams, you'll need to provide "file"-related information manually.
              // See the `form-data` README for more information about options: https://github.com/form-data/form-data
              file: {
                value:  fs.createReadStream('/file'),
                options: {
                  filename: 'someImage.jpg',
                  contentType: 'image/jpeg'
                }
              }
            };
            return this.dataSource.request({ formData });
          });
          ```

      - name: Request like features
        description: |
          To help on the transition from `request` to `got`, there are some alias and helpfull fields that feels like still using request library:

          - Use 'json' as an object to POST json data (content-type: application/json):
          ```json
            {
              "json": {
                "someFiled":"someValue"
              }
            }
          ```
          - Use 'form' as an object to POST data as url encoded form (content-type:application/x-www-form-urlencoded):
          ```json
            {
              "form": {
                "someFiled":"someValue"
              }
            }
          ```

          - Custom `Agent` allowing the following features:
            - http_proxy and https_proxy environment variables
            - Request using custom certificates throught 'cert' and 'key' native NODEJS fields
            - StricSSL enable throught 'rejectUnauthorized' field

      - name: Debug
        description: |
          One of the main purpose of `bautajs` is provide a nice debugging experience. 
          The request options, the response body and the times a request takes are logged.
          To activate the logs just set debug:

          ```cmd
          LOG_LEVEL=debug DEBUG=bautajs*
          ```
          Furthemore, if you want to censor some words we strongly recomend use [pino redaction](https://github.com/pinojs/pino/blob/master/docs/redaction.md)

      - name: LoopbackFilters
        description: |
          The `bautajs` allows to use [loopback filters](https://loopback.io/doc/en/lb3/Querying-data.html) over arrays.
          Add the applyLoopbackFilters option to datasource operations:

          ### Example

          ```json
          {
            "testService":{
              "operations":[
                {
                  "name":"test",
                  "url":"http://myserver.com",
                  "applyLoopbackFilters": true,
                  "options":{
                    "json": true
                  }
                }
              ]
            }
          }
          ```

          Given the received data:

          ```json
          [
            {
              "code":"foo"
            },
            {
              "code":"bar"
            }
          ]
          ```

          Applying the given filter `?filter[where][code]=foo`, the result will be:

          ```json
          [
            {
              "code":"foo"
            }
          ]
          ```

      - name: next, previous and fork hooks
        description: |
          Another `bautajs` cool feature are hooks. Modify and add new behaviours before/after the data is being requested/received. 
          Also it accepts to fork the request chain to process hooks in parallel.
          See full examples on [Next](/#next), [Fork](/#fork) and [Previous](/#previous)

      - name: API versioning
        description: |
          The `bautajs` has API versioning out of the box to version the services and datasources easily.

          ### API definition

          The API definition is where are defined API versions, see {@link ./lib/validators/api-definition-schema.json}

          ### Example

          This is an example of API definitions for two API versions:

          ```json
          [
            {
              "versionId": "v1",
              "swagger": "2.0",
              "apiVersion": "1.0",
              "info": {
                "description": "A new API",
                "version": "1.0.0",
                "title": "CORE API"
              },
              "basePath": "/v1/api/"
            },
            {
              "versionId": "v2",
              "swagger": "2.0",
              "apiVersion": "2.0",
              "info": {
                "description": "A new API",
                "version": "1.0.0",
                "title": "CORE API"
              },
              "basePath": "/v2/api/"
            }
          ]
          ```

          API versions are accesible by code too:

          ```js
          const { services } = require('bautajs');

          services.cats.v1.find.exec();
          services.cats.v2.find.exec();
          ```

          In this example the `cats.v2` is inheriting automatically the behaviour of `cats.v1`

          ### Example of no inheritance

          This is an example of API definitions for two API versions without inheritance:

          ```json
          [
            {
              "versionId": "v1",
              "swagger": "2.0",
              "apiVersion": "1.0",
              "info": {
                "description": "A new API",
                "version": "1.0.0",
                "title": "CORE API"
              },
              "basePath": "/v1/api/"
            },
            {
              "versionId": "v2",
              "swagger": "2.0",
              "apiVersion": "2.0",
              "info": {
                "description": "A new API",
                "version": "1.0.0",
                "title": "CORE API"
              },
              "basePath": "/v2/api/",
              "noInheritance":{
                "cats":["find"]
              }
            }
          ]
          ```

          Then the two versions will have a different behaviour:

          ```js
          const { services } = require('bautajs');

          services.cats.v1.find.exec();
          services.cats.v2.find.exec(); // The result of this will be different from the v1
          ```

          ### Example of different datasources by version

          This is an example of API definitions for two API versions without inheritance:
          ```json
          [
            {
              "versionId": "v1",
              "swagger": "2.0",
              "apiVersion": "1.0",
              "info": {
                "description": "A new API",
                "version": "1.0.0",
                "title": "CORE API"
              },
              "basePath": "/v1/api/"
            },
            {
              "versionId": "v2",
              "swagger": "2.0",
              "apiVersion": "2.0",
              "info": {
                "description": "A new API",
                "version": "1.0.0",
                "title": "CORE API"
              },
              "basePath": "/v2/api/"
            }
          ]
          ```

          This will be the datasource for the different versions:

          ```json
          {
            "cats":{
              "operations":[
                {
                  "name":"find",
                  "url":"http://google.es"
                },
                {
                  "name":"find",
                  "url":"http://facebook.es",
                  "versionId":"v2"
                }
              ]
            }
          }
          ```
          So as you can see here the v1 `cats.find` will fetch the data from google.es and v2 will fetch data from facebook.com.
          Datasources without `versionId` will be applied to all the API versions. Also, `versionId` must match with the API definition `versionId`.
      - name: Set an Operation schema (endpoint schema)
        description: |
          bautajs provides the way to associate an [OPENAPI](https://github.com/OAI/OpenAPI-Specification) definition to one operation. Later this
          will have multiple uses:
            - As an input validation if the option validateRequest is set to true or if the `this.validate()` function is called inside the loader.
            - To expose the service through an API endpoint.
            - To add the endpoint on the swagger explorer
            - Your imagination ;)

          Take in account you can access to the definitions set when you create the bautajs instance on your API definition under definions field, that way
          you are hable to share schema definitions between operation schemas.

          Example:
          my-schema.json
          ```json
            {
              "/cats/{catId}": {
                "get": {
                  "tags": ["cats"],
                  "summary": "Get cats by id",
                  "parameters": [
                    {
                      "in": "path",
                      "name": "catId",
                      "required": true,
                      "type": "string",
                      "description": "The identifier of the cat"
                  ],
                  "operationId": "get-cats-catsId",
                  "produces": ["application/json"],
                  "responses": {
                    "201": {
                      "schema": {
                        "$ref": "#/definitions/Cat"
                      }
                    },
                    "401": {
                      "description": "Not authorized",
                      "schema": {
                        "$ref": "#/definitions/Error"
                      }
                    },
                    "422": {
                      "description": "Unprocessable entity",
                      "schema": {
                        "$ref": "#/definitions/Error"
                      }
                    },
                    "500": {
                      "description": "Internal server error.",
                      "schema": {
                        "$ref": "#/definitions/Error"
                      }
                    }
                  }
                }
              }
            }
          ```
          some-loader.js
          ```js
            const mySchema = require('./my-schema.json')
            module.exports = (services) => {
                services.myService.v1.find.setSchema(mySchema)
            }

          ```
  - name: Public API
    children:
      - services
      - requireAll
      - store
      - batuajs
      - deref
      - name: Artifacts
        description: |
          A set of artifacts that bautajs provides when use its public API
        children:
          - Operation
          - Fork
          - Step
          - Service
          - Version
